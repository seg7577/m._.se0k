/*
문제 : 옛날 옛적에 수학이 항상 큰 골칫거리였던 나라가 있었다. 이 나라의 국왕 김지민은 다음과 같은 문제를 내고 큰 상금을 걸었다.
길이가 n인 정수 배열 a와 b가 있다. 다음과 같이 함수 s를 정의하자.S = A[0] × B[0] + ... + A[N-1] × B[N-1]
S의 값을 가장 작게 만들기 위해 A의 수를 재배열하자. 단, B에 있는 수는 재배열하면 안된다. S의 최솟값을 출력하는 프로그램을 작성하시오.
------------------------------------------------------------------------------------------------------------
입력 : 첫째 줄에 n이 주어진다. 둘째 줄에는 a에 있는 n개의 수가 순서대로 주어지고, 셋째 줄에는 b에 있는 수가 순서대로 주어진다. n은 50보다 작거나 같은 자연수이고, a와 b의 각 원소는 100보다 작거나 같은 음이 아닌 정수이다.
출력 : 첫째 줄에 s의 최솟값을 출력한다.
 ------------------------------------------------------------------------------------------------------------
풀이 : "S = A[0] × B[0] + ... + A[N-1] × B[N-1]" 이므로 각각의 배열 a는 오름차순, b는 내림차순으로 배열 후 계산을 해주면 풀리는 문제이다.
*/

#include <iostream>
#include <algorithm>
#define MAX 55
using namespace std;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    int n;
    int a[MAX], b[MAX];
    bool vis[MAX];
    
    cin >> n;
    for (int i = 0; i < n; i++)
        cin >> a[i];
    for (int i = 0; i < n; i++)
        cin >> b[i];
    
    sort(a, a + n);
    sort(b, b + n, greater());
    
    int answer = 0;
    for (int i = 0; i < n; i++)
        answer = answer + (a[i] * b[i]);
    
    cout << answer << '\n';
}
