
/*
백트래킹 : 현재 상태에서 가능한 모든 후보군을 따라 들어가며 탐색하는 알고리즘
---------------------------------------------------------------------------------------------
문제 : 자연수 n과 m이 주어졌을 때, 아래 조건을 만족하는 길이가 m인 수열을 모두 구하는 프로그램을 작성하시오.
1. 1부터 n까지 자연수 중에서 중복 없이 m개를 고른 수열
2. 고른 수열은 오름차순이어야 한다.

---------------------------------------------------------------------------------------------
입력 : 첫째 줄에 자연수 n과 m이 주어진다.
출력 : 한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력ㄷ한다. 중복되는 수열을 여러 번 출력3하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.
수열은 사전 순으로 증가하는 순서로 출력해야 한다.

---------------------------------------------------------------------------------------------
풀이 : 앞 문제인 n과 m(1)에서의 백트래킹 코드를 본 떠서 진행하며 visted를 하나 더 사용하여 중복된 수열 및 오름차순을 만들어보려고 했으나 해내지 못했다..
그렇게 고민하던 중 반복문을 유심히 보니 한 가지를 알 수 있었다. 함수가 호출되고 재귀로 호출된 경우 이전의 반복문에서의 i까지는 반복을 건너 뛴다는 점이였다.(조건문을 통해 내부 코드가 실행되지 않음을 말함.)
이를 이용하면 함수 매개변수(parameter)을 하나 더 만들어 반복문의 시작점을 반복된 지점까지 이어서 하게 하여 오름차순을 구성하게 되었다.
*/



#include <iostream>
#define MAX 10
using namespace std;

int n, m;
int arr[MAX];
bool vis[MAX];

void func(int k, int start)
{
    if(k == m)
    {
        for (int i = 0; i < m; i++)
            cout << arr[i] << ' ';
        cout << '\n';
        
        return;
    }
    
    for (int i = start; i <= n; i++)
    {
        if (!vis[i])
        {
            arr[k] = i;
            vis[i] = true;
            func(k+1, i);
            vis[i] = false;
        }
    }
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin >> n >> m;
    func(0, 1);
    
    return 0;
}
