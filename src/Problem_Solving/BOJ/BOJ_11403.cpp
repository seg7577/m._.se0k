/*
 문제 : 가중치 없는 방향 그래프 g가 주어졌을 때, 모든 정점(i, j)에 대해서 , i에서 j로 가는 길이가 양수인 경로가 있는 지 없는 지 구하는 프로그램을 작성하시오.
 ---------------------------------------------------------------------------------------------------------------------------------
 입력 : 첫째 줄에 정점의 개수 N((1 ≤ N ≤ 100)이 주어진다. 둘째 줄부터 n개 줄에는 그래프의 인접 행렬이 주어진다. i번째 줄의 j번째 숫자가 1인 경우에는 i에서 j로 가는 간선이 존재한다는 뜻이고, 0인 경우는 없다는 뜻이다. i번째 줄의 i번째 숫자는 항상 0이다.
 출력 : 총 N개의 줄에 걸쳐서 문제의 정답을 인접행렬 형식으로 출력한다. 정점 i에서 j로 가는 길이가 양수인 경로가 있으면 i번째 줄의 j번째 숫자를 1로, 없으면 0으로 출력해야 한다.
 ---------------------------------------------------------------------------------------------------------------------------------
 풀이 : 해당 노드와 연결이 되어 있는 노드들에 대한 번호를 각각 vector형 배열에 저장함. 이후 해당 노드들의 연결 유무를 파악하기 위해 0번부터 ~ n번의 노드까지 반복을 진행하며 i번 노드에서부터 방문 가능한 노드들을 순차적으로 탐색하며 vis에 기록함.
*/

#include <iostream>
#include <vector>
#include <cstring>
#define MAX 105

using namespace std;

bool vis[MAX];
int n, num;

vector<int> vec[MAX];
void DFS(int x)
{
    for (int i = 0; i < vec[x].size(); i++)
    {
        if (!vis[vec[x][i]])
        {
            vis[vec[x][i]] = true;
            DFS(vec[x][i]);
        }
    }
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    cin >> n;
    
    int num;
    for (int i = 0; i < n; i++)
    //해당 노드와 연결 되어 있는 노드들을 vector에 저장(무방향 그래프)
        for (int j = 0; j < n; j++)
        {
            cin >> num;
            if (num)    vec[i].push_back(j);
        }
    
    for (int i = 0; i < n; i++)
    //각 노드들의 연결 유무를 파악하기 위해 모든 노드들에 대한 완전 탐색 진행.
    //각 노드들의 방문 여부가 겹치지 않기 위해 반복마다 vis를 초기화함.
    //i번 노드에 대한 탐색이 종료되면, vis에 i번부터 n번의 노드까지의 방문 가능 여부 표시(vis)를 기반으로 출력을 진행함.
    {
        memset(vis, false, sizeof(vis));
        DFS(i);
        
        for (int j = 0; j < n; j++)
        {
            if (vis[j])
                cout << 1 << ' ';
            else
                cout << 0 << ' ';
        }
        cout << '\n';
    }
}
