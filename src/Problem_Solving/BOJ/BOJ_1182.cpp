/*
문제 : n개의 정수로 이루어진 수열이 있을 때, 크기가 양수인 부분수열 중에서 그 수열의 원소를 다 더한 값이 s가 되는 경우의 수를 구하는 프로그램을 작성하시오.
---------------------------------------------------------------------------------------------------------------------------------
입력 : 첫째 줄에 정수의 개수를 나타내는 n과 정수 s가 주어진다.(1 ≤ N ≤ 20, |S| ≤ 1,000,000) 둘째 줄에 n개의 정수가 빈 칸을 사이에 두고 주어진다. 주어지는 정수의 절댓값은 100,000을 넘지 않는다.
출력 : 첫째 줄에 합이 s가 뙤는 부분수열의 개수를 출력한다.
---------------------------------------------------------------------------------------------------------------------------------
플이 : 백트래킹은..."현재 상태에서 가능한 모든 후보군을 따라 들어가며 탐색하는 알고리즘" 라고는 하는데 그냥 dfs에서 뒤에서부터 하면 장땡인...그런..그런...그런...
일단 dfs를 하기 위해 트리 구조로 형상화를 하였고, 이후 가지치기? 할 때는 해당 인덱스의 값이 포함 되는 경우, 안 되는 경우 두 가지로 나누어서 dfs를 두 번씩 호출하여 재귀로 풀어냈다. 여기서 주의할 점은 현재 원소를 포함하지 않는 경우로 탐색을 진행하다 보면 공집합이 포함되는 경우가 발생할 수 있기 때문에 s == 0인 경우에는 탐색이 종료된 이후 answer--를 해주었다.
*/

#include <iostream>
using namespace std;

int n, s, answer = 0;
int arr[25];

void func(int idx, int sum) {
    if (idx == n) {  // 배열의 끝에 도달한 경우
        if (sum == s) answer++;
        return;
    }

    // 현재 원소를 포함하지 않는 경우
    func(idx + 1, sum);
    
    // 현재 원소를 포함하는 경우
    func(idx + 1, sum + arr[idx]);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> n >> s;
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    func(0, 0);  // 시작 인덱스와 합 0으로 초기화

    // s가 0인 경우, 공집합(빈 부분수열)이 포함되므로 이를 제외
    if (s == 0) answer--;

    cout << answer << '\n';
    return 0;
}
